#include "ELECHOUSE_CC1101_SRC_DRV.h"
#include <WiFiClient.h> 
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebSrv.h>
#include <AsyncElegantOTA.h>
#define DEST_FS_USES_SD
#include <ESP32-targz.h>
#include <SPIFFSEditor.h>
#include <EEPROM.h>
#include "SPIFFS.h"
#include "SPI.h"
#include <WiFiAP.h>
#include "FS.h"
#include "SD.h"

#define eepromsize 4096
#define samplesize 2000

#define SD_SCLK 18
#define SD_MISO 19
#define SD_MOSI 23
#define SD_SS   22

SPIClass sdspi(VSPI);

#if defined(ESP8266)
    #define RECEIVE_ATTR ICACHE_RAM_ATTR
#elif defined(ESP32)
    #define RECEIVE_ATTR IRAM_ATTR
#else
    #define RECEIVE_ATTR
#endif

// Config SSID, password and channel
const char* ssid = "Evil Crow RF v2";  // Enter your SSID here
const char* password = "hunter0047";  //Enter your Password here
const int wifi_channel = 12; //Enter your preferred Wi-Fi Channel

// HTML and CSS style

const String HTML_CSS_STYLING = "<head><meta charset='UTF-8'><title>EvilCrowRF</title><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css'><link rel='stylesheet' href='./style.css'><link rel='icon' href='ECRF.ico' type='image/x-icon'><script src='lib.js'></script></head>";

//Pushbutton Pins
int push1 = 34;
int push2 = 35;

int led = 32;
static unsigned long Blinktime = 0;

int error_toleranz = 200;

int RXPin = 26;
int RXPin0 = 4;
int TXPin0 = 2;
int Gdo0 = 25;
const int minsample = 30;
unsigned long sample[samplesize];
unsigned long samplesmooth[samplesize];
int samplecount;
static unsigned long lastTime = 0;
String transmit = "";
long data_to_send[2000];
long data_button1[2000];
long data_button2[2000];
long data_button3[2000];
long transmit_push[2000];
String tmp_module;
String tmp_frequency;
String tmp_xmlname;
String tmp_codelen;
String tmp_setrxbw;
String tmp_mod;
int mod;
String tmp_deviation;
float deviation;
String tmp_datarate;
String tmp_powerjammer;
int power_jammer;
int datarate;
float frequency;
float setrxbw;
String raw_rx = "0";
String jammer_tx = "0";
const bool formatOnFail = true;
String webString;
String bindata;
int samplepulse;
String tmp_samplepulse;
String tmp_transmissions;
int counter=0;
int pos = 0;
int transmissions;
int pushbutton1 = 0;
int pushbutton2 = 0;
byte jammer[11] = {0xff,0xff,};

//BTN Sending Config
int btn_set_int;
String btn_set;
String btn1_frequency;
String btn1_mod;
String btn1_rawdata;
String btn1_deviation;
String btn1_transmission;
String btn2_frequency;
String btn2_mod;
String btn2_rawdata;
String btn2_deviation;
String btn2_transmission;
float tmp_btn1_deviation;
float tmp_btn2_deviation;
float tmp_btn1_frequency;
float tmp_btn2_frequency;
int tmp_btn1_mod;
int tmp_btn2_mod;
int tmp_btn1_transmission;
int tmp_btn2_transmission;
String bindataprotocol;
String bindata_protocol;
String btn1tesla = "0";
String btn2tesla = "0";
float tmp_btn1_tesla_frequency;
float tmp_btn2_tesla_frequency;

// Wi-Fi config storage
int storage_status;
String tmp_config1;
String tmp_config2;
String config_wifi;
String ssid_new;
String password_new;
String tmp_channel_new;
String tmp_mode_new;
int channel_new;
int mode_new;

// Tesla
const uint16_t pulseWidth = 400;
const uint16_t messageDistance = 23;
const uint8_t transmtesla = 5;
const uint8_t messageLength = 43;

const uint8_t sequence[messageLength] = { 
  0x02,0xAA,0xAA,0xAA,  // Preamble of 26 bits by repeating 1010
  0x2B,                 // Sync byte
  0x2C,0xCB,0x33,0x33,0x2D,0x34,0xB5,0x2B,0x4D,0x32,0xAD,0x2C,0x56,0x59,0x96,0x66,
  0x66,0x5A,0x69,0x6A,0x56,0x9A,0x65,0x5A,0x58,0xAC,0xB3,0x2C,0xCC,0xCC,0xB4,0xD2,
  0xD4,0xAD,0x34,0xCA,0xB4,0xA0};

// Jammer
int jammer_pin;

// File
File logs;
File file;

AsyncWebServer controlserver(80);

void readConfigWiFi(fs::FS &fs, String path){
  File file = fs.open(path);
  
  if(!file || file.isDirectory()){
    storage_status = 0;
    return;
  }
  
  while(file.available()){
    config_wifi = file.readString();
    int file_len = config_wifi.length()+1;
    int index_config = config_wifi.indexOf('\n');
    tmp_config1 = config_wifi.substring(0, index_config-1);
    
    tmp_config2 = config_wifi.substring(index_config+1, file_len-3);
    storage_status = 1;
  }
  file.close();
}

void writeConfigWiFi(fs::FS &fs, const char * path, String message){
    File file = fs.open(path, FILE_APPEND);
    
    if(!file){
      return;
    }
    
    if(file.println(message)){
    } else {
    }
    file.close();
}

// handles uploads
void handleUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final) {
  String logmessage = "Client:" + request->client()->remoteIP().toString() + " " + request->url();

  if (!index) {
    logmessage = "Upload Start: " + String(filename);
    request->_tempFile = SD.open("/URH/" + filename, "w");
  }

  if (len) {
    request->_tempFile.write(data, len);
    logmessage = "Writing file: " + String(filename) + " index=" + String(index) + " len=" + String(len);
  }

  if (final) {
    logmessage = "Upload Complete: " + String(filename) + ",size: " + String(index + len);
    request->_tempFile.close();
    request->redirect("/");
  }
}

// handles uploads SD Files
void handleUploadSD(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final) {
  removeDir(SD, "/HTML");
  String logmessage = "Client:" + request->client()->remoteIP().toString() + " " + request->url();

  if (!index) {
    logmessage = "Upload Start: " + String(filename);
    request->_tempFile = SD.open("/" + filename, "w");
  }

  if (len) {
    request->_tempFile.write(data, len);
    logmessage = "Writing file: " + String(filename) + " index=" + String(index) + " len=" + String(len);
  }

  if (final) {
    logmessage = "Upload Complete: " + String(filename) + ",size: " + String(index + len);
    request->_tempFile.close();
    tarGzFS.begin();

    TarUnpacker *TARUnpacker = new TarUnpacker();

    TARUnpacker->haltOnError( true ); // stop on fail (manual restart/reset required)
    TARUnpacker->setTarVerify( true ); // true = enables health checks but slows down the overall process
    TARUnpacker->setupFSCallbacks( targzTotalBytesFn, targzFreeBytesFn ); // prevent the partition from exploding, recommended
    TARUnpacker->setTarProgressCallback( BaseUnpacker::defaultProgressCallback ); // prints the untarring progress for each individual file
    TARUnpacker->setTarStatusProgressCallback( BaseUnpacker::defaultTarStatusProgressCallback ); // print the filenames as they're expanded
    TARUnpacker->setTarMessageCallback( BaseUnpacker::targzPrintLoggerCallback ); // tar log verbosity

    if( !TARUnpacker->tarExpander(tarGzFS, "/HTML.tar", tarGzFS, "/") ) {
      Serial.printf("tarExpander failed with return code #%d\n", TARUnpacker->tarGzGetError() );
    }
    deleteFile(SD, "/HTML.tar");
    request->redirect("/");
  }
}

void listDir(fs::FS &fs, const char * dirname, uint8_t levels){
  deleteFile(SD, "/dir.txt");

  File root = fs.open(dirname);
  if(!root){
    return;
  }
  if(!root.isDirectory()){
    return;
  }

  File file = root.openNextFile();
  while(file){
    if(file.isDirectory()){
      appendFile(SD, "/dir.txt","  DIR : ", file.name());
      if(levels){
        listDir(fs, file.name(), levels -1);
      }
    } else {
      appendFile(SD, "/dir.txt","", "<br>");
      appendFile(SD, "/dir.txt","", file.name());
      appendFile(SD, "/dir.txt","  SIZE: ", "");
      appendFileLong(SD, "/dir.txt",file.size());
    }
    file = root.openNextFile();
  }
}

void appendFile(fs::FS &fs, const char * path, const char * message, String messagestring){

  logs = fs.open(path, FILE_APPEND);
  if(!logs){
    //Serial.println("Failed to open file for appending");
    return;
  }
  if(logs.print(message)|logs.print(messagestring)){
    //Serial.println("Message appended");
  } else {
    //Serial.println("Append failed");
  }
  logs.close();
}

void appendFileLong(fs::FS &fs, const char * path, unsigned long messagechar){
  //Serial.printf("Appending to file: %s\n", path);

  logs = fs.open(path, FILE_APPEND);
  if(!logs){
    //Serial.println("Failed to open file for appending");
    return;
  }
  if(logs.print(messagechar)){
    //Serial.println("Message appended");
  } else {
    //Serial.println("Append failed");
  }
  logs.close();
}

void deleteFile(fs::FS &fs, const char * path){
  //Serial.printf("Deleting file: %s\n", path);
  if(fs.remove(path)){
    //Serial.println("File deleted");
  } else {
    //Serial.println("Delete failed");
  }
}

void readFile(fs::FS &fs, String path){
  //Serial.printf("Reading file: %s\n", path);

  File file = fs.open(path);
  if(!file){
    //Serial.println("Failed to open file for reading");
    return;
  }

  //Serial.print("Read from file: ");
  while(file.available()){
    bindataprotocol = file.readString();
    //Serial.println("");
    //Serial.println(bindataprotocol);
  }
  file.close();
}


void removeDir(fs::FS &fs, const char * dirname){

  File root = fs.open(dirname);
  if(!root){
    //Serial.println("Failed to open directory");
    return;
  }
  if(!root.isDirectory()){
    //Serial.println("Not a directory");
    return;
  }

  File file = root.openNextFile();
  while(file){
    //Serial.print(file.name());
    //Serial.println("");
    
    if(file.isDirectory()){
      deleteFile(SD, file.name());
    } else {
      deleteFile(SD, file.name());
    }
    file = root.openNextFile();
  }
}

bool checkReceived(void){
  
  delay(1);
  if (samplecount >= minsample && micros()-lastTime >100000){
    detachInterrupt(RXPin0);
    detachInterrupt(RXPin);
    return 1;
  }else{
    return 0;
  }
}

void printReceived(){
  
  Serial.print("Count=");
  Serial.println(samplecount);
  appendFile(SD, "/logs.txt", NULL, "<br>\n");
  appendFile(SD, "/logs.txt", NULL, "Count=");
  appendFileLong(SD, "/logs.txt", samplecount);
  appendFile(SD, "/logs.txt", NULL, "<br>");
  
  for (int i = 1; i<samplecount; i++){
    Serial.print(sample[i]);
    Serial.print(",");
    appendFileLong(SD, "/logs.txt", sample[i]);
    appendFile(SD, "/logs.txt", NULL, ",");  
  }
  Serial.println();
  Serial.println();
  appendFile(SD, "/logs.txt", "<br>\n", "<br>\n");
  appendFile(SD, "/logs.txt", "\n", "\n");
}

void RECEIVE_ATTR receiver() {
  const long time = micros();
  const unsigned int duration = time - lastTime;

  if (duration > 100000){
    samplecount = 0;
  }

  if (duration >= 100){
    sample[samplecount++] = duration;
  }

  if (samplecount>=samplesize){
    detachInterrupt(RXPin0);
    detachInterrupt(RXPin);
    checkReceived();
  }

  if (mod == 0 && tmp_module == "2") {
    if (samplecount == 1 and digitalRead(RXPin) != HIGH){
      samplecount = 0;
    }
  }
  
  lastTime = time;
}

void enableReceive(){
  pinMode(RXPin0,INPUT);
  RXPin0 = digitalPinToInterrupt(RXPin0);
  ELECHOUSE_cc1101.SetRx();
  samplecount = 0;
  attachInterrupt(RXPin0, receiver, CHANGE);
  pinMode(RXPin,INPUT);
  RXPin = digitalPinToInterrupt(RXPin);
  ELECHOUSE_cc1101.SetRx();
  samplecount = 0;
  attachInterrupt(RXPin, receiver, CHANGE);
}

void parse_data() {

  bindata_protocol = "";
  int data_begin_bits = 0;
  int data_end_bits = 0;
  int data_begin_pause = 0;
  int data_end_pause = 0;
  int data_count = 0;

  for (int c = 0; c<bindataprotocol.length(); c++){
    if (bindataprotocol.substring(c,c+4) == "bits"){
      data_count++;
    }
  }

  for (int d = 0; d<data_count; d++){
    data_begin_bits = bindataprotocol.indexOf("<message bits=", data_end_bits);
    data_end_bits = bindataprotocol.indexOf("decoding_index=", data_begin_bits+1);
    bindata_protocol += bindataprotocol.substring(data_begin_bits+15, data_end_bits-2);
      
    data_begin_pause = bindataprotocol.indexOf("pause=", data_end_pause);
    data_end_pause = bindataprotocol.indexOf(" timestamp=", data_begin_pause+1);
    bindata_protocol += "[Pause: ";
    bindata_protocol += bindataprotocol.substring(data_begin_pause+7, data_end_pause-1);
    bindata_protocol += " samples]\n";
  }
  bindata_protocol.replace(" ","");
  bindata_protocol.replace("\n","");
  bindata_protocol.replace("Pause:","");
  Serial.println("Parsed Data:");
  Serial.println(bindata_protocol);
}

void sendSignals() {
  pinMode(TXPin0,OUTPUT);
  ELECHOUSE_cc1101.setModul(0);
  ELECHOUSE_cc1101.Init();
  ELECHOUSE_cc1101.setModulation(2);
  ELECHOUSE_cc1101.setMHZ(frequency);
  ELECHOUSE_cc1101.setDeviation(0);
  ELECHOUSE_cc1101.SetTx();
  
  for (uint8_t t=0; t<transmtesla; t++) {
    for (uint8_t i=0; i<messageLength; i++) sendByte(sequence[i]);
      digitalWrite(TXPin0, LOW);
      delay(messageDistance);
    }
}

void sendSignalsBT1() {
  pinMode(TXPin0,OUTPUT);
  ELECHOUSE_cc1101.setModul(0);
  ELECHOUSE_cc1101.Init();
  ELECHOUSE_cc1101.setModulation(2);
  ELECHOUSE_cc1101.setMHZ(tmp_btn1_tesla_frequency);
  ELECHOUSE_cc1101.setDeviation(0);
  ELECHOUSE_cc1101.SetTx();
  
  for (uint8_t t=0; t<transmtesla; t++) {
    for (uint8_t i=0; i<messageLength; i++) sendByte(sequence[i]);
      digitalWrite(TXPin0, LOW);
      delay(messageDistance);
    }
}

void sendSignalsBT2() {
  pinMode(TXPin0,OUTPUT);
  ELECHOUSE_cc1101.setModul(0);
  ELECHOUSE_cc1101.Init();
  ELECHOUSE_cc1101.setModulation(2);
  ELECHOUSE_cc1101.setMHZ(tmp_btn2_tesla_frequency);
  ELECHOUSE_cc1101.setDeviation(0);
  ELECHOUSE_cc1101.SetTx();
  
  for (uint8_t t=0; t<transmtesla; t++) {
    for (uint8_t i=0; i<messageLength; i++) sendByte(sequence[i]);
      digitalWrite(TXPin0, LOW);
      delay(messageDistance);
    }
}

void sendByte(uint8_t dataByte) {
  for (int8_t bit=7; bit>=0; bit--) { // MSB
    digitalWrite(TXPin0, (dataByte & (1 << bit)) != 0 ? HIGH : LOW);
    delayMicroseconds(pulseWidth);
  }
}

void power_management(){
  EEPROM.begin(eepromsize);

  pinMode(push2, INPUT);
  pinMode(led, OUTPUT);

  byte z = EEPROM.read(eepromsize-2);
  if (digitalRead(push2) != LOW){
    if (z == 1){
      go_deep_sleep();
    }
      }else{
    if (z == 0){
      EEPROM.write(eepromsize-2, 1);
      EEPROM.commit();
      go_deep_sleep();
    }else{
      EEPROM.write(eepromsize-2, 0);
      EEPROM.commit();
    }
  }
}

void go_deep_sleep(){
  Serial.println("Going to sleep now");
  ELECHOUSE_cc1101.setModul(0);
  ELECHOUSE_cc1101.goSleep();
  ELECHOUSE_cc1101.setModul(1);
  ELECHOUSE_cc1101.goSleep();
  led_blink(5,250);
  esp_deep_sleep_start();
}

void led_blink(int blinkrep,int blinktimer){
  for (int i = 0; i<blinkrep; i++){
    digitalWrite(led, HIGH);
    delay(blinktimer);
    digitalWrite(led, LOW);
    delay(blinktimer);
  }
}

void poweron_blink(){
  if (millis()-Blinktime > 10000){
    digitalWrite(led, LOW);
  }
  if (millis()-Blinktime > 10100){
    digitalWrite(led, HIGH);
    Blinktime = millis();
  }
}

void force_reset() {
  esp_task_wdt_init(1,true);
  esp_task_wdt_add(NULL);
  while(true);
}

void setup() {

  Serial.begin(38400);
  power_management();

  SPIFFS.begin(formatOnFail);

  readConfigWiFi(SPIFFS,"/configwifi.txt");
  ssid_new = tmp_config1;
  password_new = tmp_config2;
  readConfigWiFi(SPIFFS,"/configmode.txt");
  tmp_channel_new = tmp_config1;
  tmp_mode_new = tmp_config2;
  channel_new = tmp_channel_new.toInt();
  mode_new = tmp_mode_new.toInt();
  
  if (storage_status == 0) {
    WiFi.mode(WIFI_AP);
    WiFi.softAP(ssid, password,wifi_channel,8);
  }

  if(storage_status == 1) {
    if(mode_new == 1) {
      WiFi.mode(WIFI_AP);
      WiFi.softAP(ssid_new.c_str(), password_new.c_str(),channel_new,8);
    }
    else if(mode_new == 2) {
      WiFi.mode(WIFI_STA);
      WiFi.begin(ssid_new.c_str(), password_new.c_str());
    } 
  }
  
  delay(2000);
  
  sdspi.begin(18, 19, 23, 22);
  SD.begin(22, sdspi);
  pinMode(push1, INPUT);
  pinMode(push2, INPUT);

  controlserver.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/index.html", "text/html");
  });

  controlserver.on("/rxconfig", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/rxconfig.html", "text/html");
  });

  controlserver.on("/txconfig", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/txconfig.html", "text/html");
  });

  controlserver.on("/txprotocol", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/txprotocol.html", "text/html");
  });

  controlserver.on("/txbinary", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/txbinary.html", "text/html");
  });

  controlserver.on("/btnconfig", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/btn3.html", "text/html");
  });

  controlserver.on("/wificonfig", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/wificonfig.html", "text/html");
  });

  controlserver.on("/btnconfigtesla", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/btnconfigtesla.html", "text/html");
  });

  controlserver.on("/txprotocol", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/txprotocol.html", "text/html");
  });

  controlserver.on("/updatesd", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/updatesd.html", "text/html");
  });

controlserver.on("/listxmlfiles", HTTP_GET, [](AsyncWebServerRequest *request) {
    String html = "<p></p>";
    
    // Listar arquivos do diretório /URH no cartão SD
    File dir = SD.open("/URH");
    if (dir) {
        while (File file = dir.openNextFile()) {
            if (file.isDirectory()) {
                // Ignorar diretórios
                continue;
            }
            html += "<p>" + String(file.name()) + "</p>";
            file.close();
        }
        
        dir.close();
    } else {
        html += "<p>Erro ao abrir o diretório.</p>";
    }

    request->send(200, "text/html", html);
});

  controlserver.on("/uploadxmlfiles", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/uploadxmlfiles.html", "text/html");
  });

  controlserver.on("/upload", HTTP_POST, [](AsyncWebServerRequest *request) {
        request->send(200); }, handleUpload);

  controlserver.on("/uploadsd", HTTP_POST, [](AsyncWebServerRequest *request) {
        request->send(200); }, handleUploadSD);

  controlserver.on("/jammer", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/jammer.html", "text/html");
  });

  controlserver.on("/txtesla", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/txtesla.html", "text/html");
  });

  controlserver.on("/stopjammer", HTTP_POST, [](AsyncWebServerRequest *request){
    jammer_tx = "0";
    request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Stop OK\")</script>");
    ELECHOUSE_cc1101.setModul(0);
    ELECHOUSE_cc1101.setSidle();
    ELECHOUSE_cc1101.setModul(1);
    ELECHOUSE_cc1101.setSidle();
  });

  controlserver.on("/stopbtntesla", HTTP_POST, [](AsyncWebServerRequest *request){
    btn1tesla = "0";
    btn2tesla = "0";
    request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Stop OK\")</script>");
    ELECHOUSE_cc1101.setSidle(); 
  });

  controlserver.on("/setjammer", HTTP_POST, [](AsyncWebServerRequest *request){
    raw_rx = "0";
    tmp_module = request->arg("module");
    tmp_frequency = request->arg("frequency");
    tmp_powerjammer = request->arg("powerjammer");

    if (request->hasArg("configmodule")) {
      frequency = tmp_frequency.toFloat();
      power_jammer = tmp_powerjammer.toInt();

      //Serial.println("Start");

      if (tmp_module == "1") {
        pinMode(2,OUTPUT);
        ELECHOUSE_cc1101.setModul(0);
        ELECHOUSE_cc1101.Init();
        ELECHOUSE_cc1101.setModulation(2);
        ELECHOUSE_cc1101.setMHZ(frequency);
        ELECHOUSE_cc1101.setPA(power_jammer);
        ELECHOUSE_cc1101.SetTx();
        //Serial.println("Module 1");
      }
      
      if (tmp_module == "2") {
        pinMode(25,OUTPUT);
        ELECHOUSE_cc1101.setModul(1);
        ELECHOUSE_cc1101.Init();
        ELECHOUSE_cc1101.setModulation(2);
        ELECHOUSE_cc1101.setMHZ(frequency);
        ELECHOUSE_cc1101.setPA(power_jammer);
        ELECHOUSE_cc1101.SetTx();
        //Serial.println("Module 2");
      }
      //sdspi.end();
      //sdspi.begin(18, 19, 23, 22);
      //SD.begin(22, sdspi);
      jammer_tx = "1"; 
      request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Jammer OK\")</script>");
    }  
  });

  controlserver.on("/settx", HTTP_POST, [](AsyncWebServerRequest *request){
    raw_rx = "0";
    tmp_module = request->arg("module");
    tmp_frequency = request->arg("frequency");
    transmit = request->arg("rawdata");
    tmp_deviation = request->arg("deviation");
    tmp_mod = request->arg("mod");
    tmp_transmissions = request->arg("transmissions");

    if (request->hasArg("configmodule")) {
      int counter=0;
      int pos = 0;
      frequency = tmp_frequency.toFloat();
      deviation = tmp_deviation.toFloat();
      mod = tmp_mod.toInt();
      transmissions = tmp_transmissions.toInt();

      for (int i = 0; i<transmit.length(); i++){
        if (transmit.substring(i, i+1) == ","){
          data_to_send[counter]=transmit.substring(pos, i).toInt();
          pos = i+1;
          counter++;
        }
      }

      if (tmp_module == "1") {
        pinMode(2,OUTPUT);
        ELECHOUSE_cc1101.setModul(0);
        ELECHOUSE_cc1101.Init();
        ELECHOUSE_cc1101.setModulation(mod);
        ELECHOUSE_cc1101.setMHZ(frequency);
        ELECHOUSE_cc1101.setDeviation(deviation);
        //delay(400);
        ELECHOUSE_cc1101.SetTx();

        for (int r = 0; r<transmissions; r++) {
          for (int i = 0; i<counter; i+=2){
            digitalWrite(2,HIGH);
            delayMicroseconds(data_to_send[i]);
            digitalWrite(2,LOW);
            delayMicroseconds(data_to_send[i+1]);
            Serial.print(data_to_send[i]);
            Serial.print(",");
          }
          delay(2000); //Set this for the delay between retransmissions
        }        
      }

      else if (tmp_module == "2") {
        pinMode(25,OUTPUT);
        ELECHOUSE_cc1101.setModul(1);
        ELECHOUSE_cc1101.Init();
        ELECHOUSE_cc1101.setModulation(mod);
        ELECHOUSE_cc1101.setMHZ(frequency);
        ELECHOUSE_cc1101.setDeviation(deviation);
        //delay(400);
        ELECHOUSE_cc1101.SetTx();

        for (int r = 0; r<transmissions; r++) {
          for (int i = 0; i<counter; i+=2){
            digitalWrite(25,HIGH);
            delayMicroseconds(data_to_send[i]);
            digitalWrite(25,LOW);
            delayMicroseconds(data_to_send[i+1]);
            Serial.print(data_to_send[i]);
            Serial.print(",");
          }
          delay(2000); //Set this for the delay between retransmissions
        }
      }     
       Serial.println();
       request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Signal has been transmitted\")</script>");
       ELECHOUSE_cc1101.setSidle();
       //sdspi.end();
       //sdspi.begin(18, 19, 23, 22);
       //SD.begin(22, sdspi);
    }
  });

  controlserver.on("/settxtesla", HTTP_POST, [](AsyncWebServerRequest *request){
    raw_rx = "0";
    tmp_frequency = request->arg("frequency");

    if (request->hasArg("configmodule")) {
      frequency = tmp_frequency.toFloat();
      sendSignals();  
      request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Signal has been transmitted\")</script>");
      ELECHOUSE_cc1101.setSidle();
    }
  });

  controlserver.on("/settxbinary", HTTP_POST, [](AsyncWebServerRequest *request){
    raw_rx = "0";
    tmp_module = request->arg("module");
    tmp_frequency = request->arg("frequency");
    bindata = request->arg("binarydata");
    tmp_deviation = request->arg("deviation");
    tmp_mod = request->arg("mod");
    tmp_samplepulse = request->arg("samplepulse");
    tmp_transmissions = request->arg("transmissions");

    if (request->hasArg("configmodule")) {
      int counter=0;
      int pos = 0;
      frequency = tmp_frequency.toFloat();
      deviation = tmp_deviation.toFloat();
      mod = tmp_mod.toInt();
      samplepulse = tmp_samplepulse.toInt();
      transmissions = tmp_transmissions.toInt();

      for (int i=0; i<1000; i++){
        data_to_send[i]=0;
      }

      bindata.replace(" ","");
      bindata.replace("\n","");
      bindata.replace("Pause:","");
      int count_binconvert=0;
      String lastbit_convert="1";
      Serial.println("");
      Serial.println(bindata);

      for (int i = 0; i<bindata.length()+1; i++){
        if (lastbit_convert != bindata.substring(i, i+1)){
          if (lastbit_convert == "1"){
            lastbit_convert="0";
          }else if (lastbit_convert == "0"){
            lastbit_convert="1";
          }
          count_binconvert++;
        }
    
        if (bindata.substring(i, i+1)=="["){
          data_to_send[count_binconvert]= bindata.substring(i+1,bindata.indexOf("]",i)).toInt();
          lastbit_convert="0";
          i+= bindata.substring(i,bindata.indexOf("]",i)).length();
        }else{
          data_to_send[count_binconvert]+=samplepulse;
        }
      }

      for (int i = 0; i<count_binconvert; i++){
        Serial.print(data_to_send[i]);
        Serial.print(",");
      }

      if (tmp_module == "1") {
        pinMode(2,OUTPUT);
        ELECHOUSE_cc1101.setModul(0);
        ELECHOUSE_cc1101.Init();
        ELECHOUSE_cc1101.setModulation(mod);
        ELECHOUSE_cc1101.setMHZ(frequency);
        ELECHOUSE_cc1101.setDeviation(deviation);
        //delay(400);
        ELECHOUSE_cc1101.SetTx();

        delay(1000);

        for (int r = 0; r<transmissions; r++) {
          for (int i = 0; i<count_binconvert; i+=2){
            digitalWrite(2,HIGH);
            delayMicroseconds(data_to_send[i]);
            digitalWrite(2,LOW);
            delayMicroseconds(data_to_send[i+1]);
          }
          delay(2000); //Set this for the delay between retransmissions    
        }
      }

      else if (tmp_module == "2") {
        pinMode(25,OUTPUT);
        ELECHOUSE_cc1101.setModul(1);
        ELECHOUSE_cc1101.Init();
        ELECHOUSE_cc1101.setModulation(mod);
        ELECHOUSE_cc1101.setMHZ(frequency);
        ELECHOUSE_cc1101.setDeviation(deviation);
        //delay(400);
        ELECHOUSE_cc1101.SetTx();  

        delay(1000);

        for (int r = 0; r<transmissions; r++) {
          for (int i = 0; i<count_binconvert; i+=2){
            digitalWrite(25,HIGH);
            delayMicroseconds(data_to_send[i]);
            digitalWrite(25,LOW);
            delayMicroseconds(data_to_send[i+1]);
          }
          delay(2000); //Set this for the delay between retransmissions    
        }
      }
      request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Signal has been transmitted\")</script>");
      ELECHOUSE_cc1101.setSidle();
      //sdspi.end();
      //sdspi.begin(18, 19, 23, 22);
      //SD.begin(22, sdspi);
    }
  });

  controlserver.on("/settxprotocol", HTTP_POST, [](AsyncWebServerRequest *request){
    raw_rx = "0";
    tmp_frequency = request->arg("frequency");
    tmp_deviation = request->arg("deviation");
    tmp_xmlname = request->arg("xmlname");
    tmp_mod = request->arg("mod");
    tmp_samplepulse = request->arg("samplepulse");

    bindata_protocol = "";
    
    if (request->hasArg("configmodule")) {
      
      int counter=0;
      int pos = 0;
      frequency = tmp_frequency.toFloat();
      deviation = tmp_deviation.toFloat();
      mod = tmp_mod.toInt();
      samplepulse = tmp_samplepulse.toInt();

      for (int i=0; i<1000; i++){
        data_to_send[i]=0;
      }

      readFile(SD, tmp_xmlname);
      //readFile(SD, "/URH/protocol.proto.xml");
      parse_data();

      int count_binconvert=0;
      String lastbit_convert="1";

      for (int i = 0; i<bindata_protocol.length()+1; i++){
        if (lastbit_convert != bindata_protocol.substring(i, i+1)){
          if (lastbit_convert == "1"){
            lastbit_convert="0";
          }else if (lastbit_convert == "0"){
            lastbit_convert="1";
          }
          count_binconvert++;
        }
    
        if (bindata_protocol.substring(i, i+1)=="["){
          data_to_send[count_binconvert]= bindata_protocol.substring(i+1,bindata_protocol.indexOf("]",i)).toInt();
          lastbit_convert="0";
          i+= bindata_protocol.substring(i,bindata_protocol.indexOf("]",i)).length();
        }else{
          data_to_send[count_binconvert]+=samplepulse;
        }
      }

      Serial.println("Data to Send");
      for (int i = 0; i<count_binconvert; i++){
        Serial.print(data_to_send[i]);
        Serial.print(",");
      }

      pinMode(2,OUTPUT);
      ELECHOUSE_cc1101.setModul(0);
      ELECHOUSE_cc1101.Init();
      ELECHOUSE_cc1101.setModulation(mod);
      ELECHOUSE_cc1101.setMHZ(frequency);
      ELECHOUSE_cc1101.setDeviation(deviation);
      //delay(400);
      ELECHOUSE_cc1101.SetTx();

      delay(1000);

      for (int i = 0; i<count_binconvert; i+=2){
        digitalWrite(2,HIGH);
        delayMicroseconds(data_to_send[i]);
        digitalWrite(2,LOW);
        delayMicroseconds(data_to_send[i+1]);
      }
     
      request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Signal has been transmitted\")</script>");
      ELECHOUSE_cc1101.setSidle();
    }
  });

  controlserver.on("/setrx", HTTP_POST, [](AsyncWebServerRequest *request){
    tmp_module = request->arg("module");
    //Serial.print("Module: ");
    //Serial.println(tmp_module);
    tmp_frequency = request->arg("frequency");
    tmp_setrxbw = request->arg("setrxbw");
    tmp_mod = request->arg("mod");
    tmp_deviation = request->arg("deviation");
    tmp_datarate = request->arg("datarate");
    if (request->hasArg("configmodule")) {
      frequency = tmp_frequency.toFloat();
      setrxbw = tmp_setrxbw.toFloat();
      mod = tmp_mod.toInt();
      //Serial.print("Modulation: ");
      //Serial.println(mod);
      deviation = tmp_deviation.toFloat();
      datarate = tmp_datarate.toInt();

      if (tmp_module == "1") {
        ELECHOUSE_cc1101.setModul(0);
        ELECHOUSE_cc1101.Init();
      }

      else if (tmp_module == "2") {
        ELECHOUSE_cc1101.setModul(1);
        ELECHOUSE_cc1101.Init();

        if(mod == 2) {
          ELECHOUSE_cc1101.setDcFilterOff(0);
        }

        if(mod == 0) {
          ELECHOUSE_cc1101.setDcFilterOff(1);
        }
        //Serial.println("Module 2");
      }

      ELECHOUSE_cc1101.setSyncMode(0);        // Combined sync-word qualifier mode. 0 = No preamble/sync. 1 = 16 sync word bits detected. 2 = 16/16 sync word bits detected. 3 = 30/32 sync word bits detected. 4 = No preamble/sync, carrier-sense above threshold. 5 = 15/16 + carrier-sense above threshold. 6 = 16/16 + carrier-sense above threshold. 7 = 30/32 + carrier-sense above threshold.
      ELECHOUSE_cc1101.setPktFormat(3);       // Format of RX and TX data. 0 = Normal mode, use FIFOs for RX and TX. 1 = Synchronous serial mode, Data in on GDO0 and data out on either of the GDOx pins. 2 = Random TX mode; sends random data using PN9 generator. Used for test. Works as normal mode, setting 0 (00), in RX. 3 = Asynchronous serial mode, Data in on GDO0 and data out on either of the GDOx pins.

      ELECHOUSE_cc1101.setModulation(mod);      // set modulation mode. 0 = 2-FSK, 1 = GFSK, 2 = ASK/OOK, 3 = 4-FSK, 4 = MSK.
      ELECHOUSE_cc1101.setRxBW(setrxbw);
      ELECHOUSE_cc1101.setMHZ(frequency);
      ELECHOUSE_cc1101.setDeviation(deviation);   // Set the Frequency deviation in kHz. Value from 1.58 to 380.85. Default is 47.60 kHz.
      ELECHOUSE_cc1101.setDRate(datarate);           // Set the Data Rate in kBaud. Value from 0.02 to 1621.83. Default is 99.97 kBaud!

      enableReceive();
      raw_rx = "1";
      //sdspi.end();
      //sdspi.begin(18, 19, 23, 22);
      //SD.begin(22, sdspi);
      request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"RX Config OK\")</script>");
    }
  });

  controlserver.on("/setbtn", HTTP_POST, [](AsyncWebServerRequest *request){
    btn_set = request->arg("button");
    btn_set_int = btn_set.toInt();
    raw_rx = "0";
    btn1tesla = "0";
    btn2tesla = "0";
    
    if (btn_set_int == 1){
      btn1_rawdata = request->arg("rawdata");
      btn1_deviation = request->arg("deviation");
      btn1_frequency = request->arg("frequency");
      btn1_mod = request->arg("mod");
      btn1_transmission = request->arg("transmissions");
      counter=0;
      int pos = 0;
      for (int i = 0; i<btn1_rawdata.length(); i++){
        if (btn1_rawdata.substring(i, i+1) == ","){
          data_button1[counter]=btn1_rawdata.substring(pos, i).toInt();
          pos = i+1;
          counter++;
        }
      }
    }
    
    if (btn_set_int == 2){
      btn2_rawdata = request->arg("rawdata");
      btn2_deviation = request->arg("deviation");
      btn2_frequency = request->arg("frequency");
      btn2_mod = request->arg("mod");
      btn2_transmission = request->arg("transmissions");
      counter=0;
      int pos = 0;
      for (int i = 0; i<btn2_rawdata.length(); i++){
        if (btn2_rawdata.substring(i, i+1) == ","){
          data_button2[counter]=btn2_rawdata.substring(pos, i).toInt();
          pos = i+1;
          counter++;
        }
      }
    }
    request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Button Config OK\")</script>");
  });

  controlserver.on("/setbtntesla", HTTP_POST, [](AsyncWebServerRequest *request){
    btn_set = request->arg("button");
    btn_set_int = btn_set.toInt();
    raw_rx = "0";
    
    if (btn_set_int == 1){
      btn1_frequency = request->arg("frequency");
      tmp_btn1_tesla_frequency = btn1_frequency.toFloat();
      //Serial.print("Freq: ");
      //Serial.println(btn1_frequency);
      btn1tesla = "1";
    }
    
    if (btn_set_int == 2){
      btn2_frequency = request->arg("frequency");
      tmp_btn2_tesla_frequency = btn2_frequency.toFloat();
      btn2tesla = "1"; 
    }
    request->send(200, "text/html", HTML_CSS_STYLING + "<script>alert(\"Button Config OK\")</script>");
  });
  
controlserver.on("/viewlog", HTTP_GET, [](AsyncWebServerRequest *request) {
    File file = SD.open("/logs.txt", "r"); // Abra o arquivo logs.txt no modo de leitura

    if (file) {
        String fileContent = "<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><title>EvilCrowRF</title><link href='style.css' rel='stylesheet'><link rel='icon' href='ECRF.ico' type='image/x-icon'><script src='javascript.js'></script></head><body><div id='nav-bar'><input id='nav-toggle' type='checkbox'><div id='nav-header'><a id='nav-title' href='/'><img src='data:image/png;base64,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'>Evil Crow RF</a><label for='nav-toggle'><span id='nav-toggle-burger'></span></label><hr></div><div id='nav-content'><div class='nav-button'><a href='/rxconfig'><svg xmlns='http://www.w3.org/2000/svg' height='.9rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M176 24c0-13.3-10.7-24-24-24s-24 10.7-24 24V64c-35.3 0-64 28.7-64 64H24c-13.3 0-24 10.7-24 24s10.7 24 24 24H64v56H24c-13.3 0-24 10.7-24 24s10.7 24 24 24H64v56H24c-13.3 0-24 10.7-24 24s10.7 24 24 24H64c0 35.3 28.7 64 64 64v40c0 13.3 10.7 24 24 24s24-10.7 24-24V448h56v40c0 13.3 10.7 24 24 24s24-10.7 24-24V448h56v40c0 13.3 10.7 24 24 24s24-10.7 24-24V448c35.3 0 64-28.7 64-64h40c13.3 0 24-10.7 24-24s-10.7-24-24-24H448V280h40c13.3 0 24-10.7 24-24s-10.7-24-24-24H448V176h40c13.3 0 24-10.7 24-24s-10.7-24-24-24H448c0-35.3-28.7-64-64-64V24c0-13.3-10.7-24-24-24s-24 10.7-24 24V64H280V24c0-13.3-10.7-24-24-24s-24 10.7-24 24V64H176V24zM160 128H352c17.7 0 32 14.3 32 32V352c0 17.7-14.3 32-32 32H160c-17.7 0-32-14.3-32-32V160c0-17.7 14.3-32 32-32zm192 32H160V352H352V160z'/></svg><span>Config</span></a></div><div class='nav-button'><a href='/txprotocol'><svg xmlns='http://www.w3.org/2000/svg' height='.9rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M62.6 2.3C46.2-4.3 27.6 3.6 20.9 20C7.4 53.4 0 89.9 0 128s7.4 74.6 20.9 108c6.6 16.4 25.3 24.3 41.7 17.7S86.9 228.4 80.3 212C69.8 186.1 64 157.8 64 128s5.8-58.1 16.3-84C86.9 27.6 79 9 62.6 2.3zm450.8 0C497 9 489.1 27.6 495.7 44C506.2 69.9 512 98.2 512 128s-5.8 58.1-16.3 84c-6.6 16.4 1.3 35 17.7 41.7s35-1.3 41.7-17.7c13.5-33.4 20.9-69.9 20.9-108s-7.4-74.6-20.9-108C548.4 3.6 529.8-4.3 513.4 2.3zM340.1 165.2c7.5-10.5 11.9-23.3 11.9-37.2c0-35.3-28.7-64-64-64s-64 28.7-64 64c0 13.9 4.4 26.7 11.9 37.2L98.9 466.8c-7.3 16.1-.2 35.1 15.9 42.4s35.1 .2 42.4-15.9L177.7 448H398.3l20.6 45.2c7.3 16.1 26.3 23.2 42.4 15.9s23.2-26.3 15.9-42.4L340.1 165.2zM369.2 384H206.8l14.5-32H354.7l14.5 32zM288 205.3L325.6 288H250.4L288 205.3zM163.3 73.6c5.3-12.1-.2-26.3-12.4-31.6s-26.3 .2-31.6 12.4C109.5 77 104 101.9 104 128s5.5 51 15.3 73.6c5.3 12.1 19.5 17.7 31.6 12.4s17.7-19.5 12.4-31.6C156 165.8 152 147.4 152 128s4-37.8 11.3-54.4zM456.7 54.4c-5.3-12.1-19.5-17.7-31.6-12.4s-17.7 19.5-12.4 31.6C420 90.2 424 108.6 424 128s-4 37.8-11.3 54.4c-5.3 12.1 .2 26.3 12.4 31.6s26.3-.2 31.6-12.4C466.5 179 472 154.1 472 128s-5.5-51-15.3-73.6z'/></svg><span>URH Protocol</span></a></div><div class='nav-button'><a href='/rfanalyze'><svg xmlns='http://www.w3.org/2000/svg' height='.9rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M128 64c0-17.7 14.3-32 32-32H320c17.7 0 32 14.3 32 32V416h96V256c0-17.7 14.3-32 32-32H608c17.7 0 32 14.3 32 32s-14.3 32-32 32H512V448c0 17.7-14.3 32-32 32H320c-17.7 0-32-14.3-32-32V96H192V256c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h96V64z'/></svg><span>RF Analyze</span></a></div><hr><div class='nav-button'><a href='/txtesla'><svg xmlns='http://www.w3.org/2000/svg' height='.9rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M176 8c-6.6 0-12.4 4-14.9 10.1l-29.4 74L55.6 68.9c-6.3-1.9-13.1 .2-17.2 5.3s-4.6 12.2-1.4 17.9l39.5 69.1L10.9 206.4c-5.4 3.7-8 10.3-6.5 16.7s6.7 11.2 13.1 12.2l78.7 12.2L90.6 327c-.5 6.5 3.1 12.7 9 15.5s12.9 1.8 17.8-2.6l35.3-32.5 9.5-35.4 10.4-38.6c8-29.9 30.5-52.1 57.9-60.9l41-59.2c11.3-16.3 26.4-28.9 43.5-37.2c-.4-.6-.8-1.2-1.3-1.8c-4.1-5.1-10.9-7.2-17.2-5.3L220.3 92.1l-29.4-74C188.4 12 182.6 8 176 8zM367.7 161.5l135.6 36.3c6.5 1.8 11.3 7.4 11.8 14.2l4.6 56.5-201.5-54 32.2-46.6c3.8-5.6 10.8-8.1 17.3-6.4zm-69.9-30l-47.9 69.3c-21.6 3-40.3 18.6-46.3 41l-10.4 38.6-16.6 61.8-8.3 30.9c-4.6 17.1 5.6 34.6 22.6 39.2l15.5 4.1c17.1 4.6 34.6-5.6 39.2-22.6l8.3-30.9 247.3 66.3-8.3 30.9c-4.6 17.1 5.6 34.6 22.6 39.2l15.5 4.1c17.1 4.6 34.6-5.6 39.2-22.6l8.3-30.9L595 388l10.4-38.6c6-22.4-2.5-45.2-19.6-58.7l-6.8-84c-2.7-33.7-26.4-62-59-70.8L384.2 99.7c-32.7-8.8-67.3 4-86.5 31.8zm-17 131a24 24 0 1 1 -12.4 46.4 24 24 0 1 1 12.4-46.4zm217.9 83.2A24 24 0 1 1 545 358.1a24 24 0 1 1 -46.4-12.4z'/></svg><span>Tesla Charge</span></a></div><div class='nav-button'><a href='/jammer'><svg xmlns='http://www.w3.org/2000/svg' height='.9rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M367.2 412.5L99.5 144.8C77.1 176.1 64 214.5 64 256c0 106 86 192 192 192c41.5 0 79.9-13.1 111.2-35.5zm45.3-45.3C434.9 335.9 448 297.5 448 256c0-106-86-192-192-192c-41.5 0-79.9 13.1-111.2 35.5L412.5 367.2zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z'/></svg><span>Simple Jammer</span></a></div><div class='nav-button'><a href='/brute'><svg xmlns='http://www.w3.org/2000/svg' height='1rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M144 144c0-44.2 35.8-80 80-80c31.9 0 59.4 18.6 72.3 45.7c7.6 16 26.7 22.8 42.6 15.2s22.8-26.7 15.2-42.6C331 33.7 281.5 0 224 0C144.5 0 80 64.5 80 144v48H64c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V256c0-35.3-28.7-64-64-64H144V144z'/></svg><span>Brute Force</span></div><hr><div class='nav-button'><a href='/rxconfig'><svg xmlns='http://www.w3.org/2000/svg' height='.9rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M448 80v48c0 44.2-100.3 80-224 80S0 172.2 0 128V80C0 35.8 100.3 0 224 0S448 35.8 448 80zM393.2 214.7c20.8-7.4 39.9-16.9 54.8-28.6V288c0 44.2-100.3 80-224 80S0 332.2 0 288V186.1c14.9 11.8 34 21.2 54.8 28.6C99.7 230.7 159.5 240 224 240s124.3-9.3 169.2-25.3zM0 346.1c14.9 11.8 34 21.2 54.8 28.6C99.7 390.7 159.5 400 224 400s124.3-9.3 169.2-25.3c20.8-7.4 39.9-16.9 54.8-28.6V432c0 44.2-100.3 80-224 80S0 476.2 0 432V346.1z'/></svg><span>RX Log</span></a></div><div class='nav-button'><a href='/wificonfig'><svg xmlns='http://www.w3.org/2000/svg' height='.9rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M54.2 202.9C123.2 136.7 216.8 96 320 96s196.8 40.7 265.8 106.9c12.8 12.2 33 11.8 45.2-.9s11.8-33-.9-45.2C549.7 79.5 440.4 32 320 32S90.3 79.5 9.8 156.7C-2.9 169-3.3 189.2 8.9 202s32.5 13.2 45.2 .9zM320 256c56.8 0 108.6 21.1 148.2 56c13.3 11.7 33.5 10.4 45.2-2.8s10.4-33.5-2.8-45.2C459.8 219.2 393 192 320 192s-139.8 27.2-190.5 72c-13.3 11.7-14.5 31.9-2.8 45.2s31.9 14.5 45.2 2.8c39.5-34.9 91.3-56 148.2-56zm64 160a64 64 0 1 0 -128 0 64 64 0 1 0 128 0z'/></svg><span>WiFi Config</span></a></div><div class='nav-button'><a href='/update'><svg xmlns='http://www.w3.org/2000/svg' height='.9rem' viewBox='0 0 700 512' fill='#8392a5' style='margin-right:13px'><path d='M105.1 202.6c7.7-21.8 20.2-42.3 37.8-59.8c62.5-62.5 163.8-62.5 226.3 0L386.3 160H336c-17.7 0-32 14.3-32 32s14.3 32 32 32H463.5c0 0 0 0 0 0h.4c17.7 0 32-14.3 32-32V64c0-17.7-14.3-32-32-32s-32 14.3-32 32v51.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0C73.2 122 55.6 150.7 44.8 181.4c-5.9 16.7 2.9 34.9 19.5 40.8s34.9-2.9 40.8-19.5zM39 289.3c-5 1.5-9.8 4.2-13.7 8.2c-4 4-6.7 8.8-8.1 14c-.3 1.2-.6 2.5-.8 3.8c-.3 1.7-.4 3.4-.4 5.1V448c0 17.7 14.3 32 32 32s32-14.3 32-32V396.9l17.6 17.5 0 0c87.5 87.4 229.3 87.4 316.7 0c24.4-24.4 42.1-53.1 52.9-83.7c5.9-16.7-2.9-34.9-19.5-40.8s-34.9 2.9-40.8 19.5c-7.7 21.8-20.2 42.3-37.8 59.8c-62.5 62.5-163.8 62.5-226.3 0l-.1-.1L125.6 352H176c17.7 0 32-14.3 32-32s-14.3-32-32-32H48.4c-1.6 0-3.2 .1-4.8 .3s-3.1 .5-4.6 1z'/></svg><span>Elegant OTA</span></a></div><hr><div id='nav-content-highlight'></div></div><input id='nav-footer-toggle' type='checkbox'><div id='nav-footer'><div id='nav-footer-heading'><div id='nav-footer-avatar'><svg xmlns='http://www.w3.org/2000/svg' version='1.0' viewBox='0 0 216 216'><path d='M0 108v108h216V0H0v108zM117 4h3a39 39 0 0 1 6 1 22 22 0 0 1 4 1h3l2 1h1l2 1h2l1 1a29 29 0 0 1 6 2l4 2a194 194 0 0 1 13 6l2 2a106 106 0 0 1 32 32l1 2a106 106 0 0 1 14 39v4a281 281 0 0 1-1 29l-1 4-1 3v1l-1 2a26 26 0 0 1-1 5v1l-1 1a9 9 0 0 1-1 2v2l-1 1-1 2a122 122 0 0 1-11 18 111 111 0 0 1-29 27l-1 1a112 112 0 0 1-41 14l-4 1H94a66 66 0 0 1-12-3 50 50 0 0 1-7-2 52 52 0 0 1-9-3 110 110 0 0 1-19-11h-1a110 110 0 0 1-35-44l-1-2-1-2v-1l-1-1v-2l-1-1-1-4v-2l-1-1v-3l-1-2v-3l-1-2v-3l-1-3a213 213 0 0 1 2-29l1-2a40 40 0 0 1 2-8v-2l1-1v-2l1-2v-1h1v-1a102 102 0 0 1 18-29l1-1a152 152 0 0 1 15-14 145 145 0 0 1 26-15h1l3-1 9-3a81 81 0 0 1 13-2h21z'/><path d='M67 15v2h-7v2h76v-2h-11v-3H67v1zm-10 7v2l1-1v1a24590 24590 0 0 0 102-1v-1h-2v-2H58v2l-1-1v1zm-1 3v5h104v-5H56zm0 6v5h52a10484 10484 0 0 0 53-3v-2H56zm-2 8v2h107v-4H54v2zm-1 3v5h109v-5H53zm0 8v2h55l54 1v-4h2-1l-1-1H53v2zm-1 6v2h112v-5H52v3zm-15 3v2h-8v3h152v-2l-4-1h-5v-2H37zm-12 6v4h164v-4H25zm0 5v3h2v2h159v-2h3v-3H25zm14 7v1h9v2h126v-2h5v-2H39v1zm17 4-2 1h-1l1 1c2 0 2 0 0 0v1h1-2l1 1h1-2v1h13v-5H56zm11 3v2h5v-2h72v2h5v-5H67v3zm86-3v5h9v-3h2-1l-1-1v-1h-9zm-99 8v3h7v-5h-7v2zm11-1v1h-1 1v1h-1v-3 3h1v1l1 1v-5h-1v1zm88 1v3h9v-5h-9v2zm-99 4v4h7v-4h-7zm103-1-1 3v2h5v-5h-4zm8 0v3h-2v2h7v-2h-3v-2l-2-1zM43 98l-1 2v3h4v-2h7-2l1 1h1-2v1h119v-5h-5a1355 1355 0 0 0-118 0h-4zm1 6v2h2v-2h-2zm9 0v1l-2 1h-2l-1 1v1h119v-4H53zm-10 5-1 3 1 2h2v-5h-2zm5 3v2h119v-5H48v3zm-4 4v1h-2v-2 3h2v2h2v-5h-2v1zm7-1v5h57v-3h5v3h54v-5H51zm-6 8v2l1-1 1-2-1-1-1-1v3zm6 0v2h5l-1-3v-2h-4v3zm7 0v2h47v-2l1-3H58v3zm57 0v2h50v-5h-50v3zm-64 5v3h3v-5h-3v2zm7 0v3h45v-5H58v2zm59-2h-1l-1 1h2l-1 1h-1 1l1 1h-2 1l1 1h-2v1h47v-3h1v-1h-1v-1h-45zm-66 6v4h3v-4h-3zm7 0v4h6v-4h-6zm10 0v2h7v2h12v-2h9v-2H68zm50 0-1 2v2h4v-4h-3zm9 0v2h14v2h19v-4h-33zm38 0v4h1v-4h-1zm-112 5v3l-1-2v-1 3-3 3l1 1v1h12v-5h-7v3h-1c-1 0-2 0-2-2v-1h-2zm66 3v2h2v-5h-2v3zm34-3v5h9v-1h-2 1l1-1h-2 5v-3h-12zm-97 7v1h2v2h3l4 1v-3c1 0 1 0 0 0v-2h-9v1zm64-1v5h2v-2h1v1-1h1v1-2h-2v-2h-2zm6 0v4h1l1 1v-5h-2zm27 0h-1l-1 1h2-1l-1 1h2-1l-1 1h2l-1 1h-1v1l3-1h4v-4h-5zm-58 2-1 1h1v1h-1v1h9v-3h-8zm-35 6v2h7v-2h1l1 1c0 1 0 1 0 0v-1h-2v-3h-7v3zm38-2h-2l1 1h1-2l1 1h1-2l2 1h-1l-1 1h31l-2-1h2v-1l1 1v1-2 1c0 1 0 1 0 0v-1h-3 2l-1-1h-1 1l1-1h-2l-5-1h-5v3h-7v-3h-5l-5 1zm53 1v1h-2v1c0 1 0 1 0 0l1-1h1v2h4v-1l1-2-1-1v-1h-4v2zm-88 4h-1l-2 1h3l-1 1h-2 3l-2 1h-1 2l1 1h-3v1h10v-5h-7zm28 1v4h1v-5l-1 1zm5-1v2h-2v3-1h1v-1l1 1v1h2l3-1v-1h-1l-2-1h3-2v-1h2l-1-1h-4zm9 0h-1l-1 1h2v1h-2 2l-1 1h-1 1l1 1h-2v1h7v-2l5-1h5-3l-2-1h5v-1h-15zm36 2v3h2v-3l1-2h-3v2zm7 0v3h6v-5h-6v2zm-33 2 2 1 3-1h-5zm-52 4v2h7v-4h-7v2zm10 0 1 2h5l-1-1c-1 0-1 0 0 0h1l-1-1h-1 2l-1-1h-1 1l1-1h-6v2zm16-2h-2l1 1h1-1c-1 0-2 0-1 1h2-1c-1 0-2 0-1 1h1l-1 1h2c2 0 2 1 2-2s0-2-1-2h-1zm5 0a40 40 0 0 0 0 4h7l-1-1c-2 0-2 0 0 0h1l-1-1h-2 1l2-1h-3 2l1-1h-7zm10 2 1 2h4v-4h-5v2zm16-2h-3l1 1h1c1 0 1 0 0 0l-2 1h2c1 0 1 0 0 0h-1l-1 1h2c1 0 1 0 0 0l-2 1h4v-4h-1zm8 2v2h4l-2-1h-1 3v-1h-3 4-1l-1-1h-2 2l1-1h-4v2zm11 0c0 3 0 2 2 2l1-2v-2h-3v2zm8 0v2h6v-4h-6v2zm-82 3v5h5v-2l1 1v1-2c1 0 0 0 0 0h-1v-3h-5zm10 0v5h4v-5h-4zm12 0v5h3v-5h-3zm4 0v5h18v-5H91zm22 0v3h-2v2-2l1 1v1-2l1 1v1h23v-5h-23zm26 0v5h3v-5h-3zm7 0v5h3v-5h-3zm-79 8v2h5v-1l1-1h-1v-2h-5v2zm8-2v1l-1 1h1l2 1v1h2v-4h-4zm29 0v4h1l1-1v-1h16v-2h-18zm30 0v2h2v-2h-2zm5 0v4h2v-1h1-1v-1s0-1 0 0l1-1h-1v-1h-2zm7 0h-1l-1 1h2-1l-1 1h2-2v1h2l-1 1h-1 3v-4h-1zm-75 8v2h6v-2h-2v-3h-4v3zm8 0v2h3v-5h-3v3zm22-1v1h14v2h7l-2-1h3-1v-1h-2l2-1h-2 1l1-1h-2l-10-1h-9v2zm38-1h-3l1 1h1c1 0 0 0 0 0h-2l2 1h1-3l1 1h2-2l-1 1h9v-5h-1l-1 1h-4zm-64 6-1 1v-2 1l-1 1v1h2v2h5l6-1h-2l1-1h1-1v-1h1l-1-1c-1 1-1 0 0 0h1l-1-1H75v1zm59 1v3h7v-3h2v-2h-9v2zm-57 5v1h2v2h7v-2l1-2H77v1zm55 0v1h-2v1c0 1 0 1 0 0v-1h2v2h7v-1l1-1v-3 3-2 1l-1 1v-2h-7v1zm-50 5v2h2v2h7v-1l1-1 1 1c0 1 0 1 0 0v-1h-4v-3h-7v1zm45 0v2h-2v2h9v-2h2v-3h-9v1zm-36 5v2h5v2h14v-1h-9 9l-6-1h-3 9l-4-1h-5 4a83 83 0 0 0 5-1H91zm24 0v2h12v-2h-12z'/></svg></div><div id='nav-footer-titlebox'><a id='nav-footer-title' href='https://github.com/DMFSouza' target='_blank'>D.Miguel</a><span id='nav-footer-subtitle' style='color:#00d166'>Hunter0047</span></div><label for='nav-footer-toggle'><i class='fas fa-caret-up'></i></label></div><div id='nav-footer-content'><lorem>Developer, passionate about the field of information security, Red Teamer with a focus on hardware hacking and social engineering.</lorem></div></div></div><main><div class='container'><div class='helper'><br><p>Arquivos de Log</p><br>";
        while (file.available()) {
            char c = file.read();
            fileContent += String(c); // Converta o caractere em uma string antes de concatená-lo
            fileContent +=<br>
        }
        file.close();
        fileContent +="<br>  <iframe  src='http://' )+local_IPstr+'/viewlog' style='visibility: hidden;'></iframe><br><form action='/delete' method='post' id='config' target='iframe'><input class='button-submit' type='submit' value='Delete Logs'></form><br><form action='/cleanspiffs' method='post' id='config' target='iframe'><input class='button-submit' type='submit' value='Clean SPIFFS'></form><br><form action='/downloadlog' method='post' id='config' target='iframe'><input class='button-submit' type='submit' value='Download Logs'></form></main></body></html>"
        request->send(200, "text/plain", fileContent); // Envie o conteúdo do arquivo como resposta
    } else {
        request->send(404, "text/plain", "Arquivo não encontrado"); // Se o arquivo não for encontrado, retorne 404
    }
});

  controlserver.on("/cleanspiffs", HTTP_GET, [](AsyncWebServerRequest *request){
    SPIFFS.remove("/");
    request->send(200, "text/html", HTML_CSS_STYLING+ "<body onload=\"JavaScript:AutoRedirect()\">"
    "<br><h2>SPIFFS cleared!<br>You will be redirected in 5 seconds.</h2></body>" );
  });

  controlserver.on("/downloadlog", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(SD, "/logs.txt", String(), true);
  });

  controlserver.on("/delete", HTTP_GET, [](AsyncWebServerRequest *request){
    deleteFile(SD, "/logs.txt");
    request->send(200, "text/html", HTML_CSS_STYLING+ "<body onload=\"JavaScript:AutoRedirect()\">"
    "<br><h2>File cleared!<br>You will be redirected in 5 seconds.</h2></body>" );
    webString="";
    appendFile(SD, "/logs.txt","Viewlog:\n", "<br>\n");
  });

  controlserver.on("/style.css", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/style.css", "text/css");
  });

  controlserver.on("/lib.js", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SD, "/HTML/javascript.js", "text/javascript");
  });

  controlserver.on("/setwificonfig", HTTP_POST, [](AsyncWebServerRequest *request) {
    String ssid_value = request->arg("ssid");
    String password_value = request->arg("password");
    String channel_value = request->arg("channel");
    String mode_value = request->arg("mode");
    
    if (request->hasArg("configmodule")) {
      deleteFile(SPIFFS, "/configwifi.txt");
      deleteFile(SPIFFS, "/configmode.txt");
      writeConfigWiFi(SPIFFS, "/configwifi.txt", ssid_value);
      writeConfigWiFi(SPIFFS, "/configwifi.txt", password_value);
      writeConfigWiFi(SPIFFS, "/configmode.txt", channel_value);
      writeConfigWiFi(SPIFFS, "/configmode.txt", mode_value);
      WiFi.disconnect();
      force_reset();
    }
  });

  controlserver.on("/deletewificonfig", HTTP_POST, [](AsyncWebServerRequest *request) {
    if (request->hasArg("configmodule")) {
      deleteFile(SPIFFS, "/configwifi.txt");
      deleteFile(SPIFFS, "/configmode.txt");
      force_reset();
    }
  });

  AsyncElegantOTA.begin(&controlserver);
  controlserver.begin();

  ELECHOUSE_cc1101.addSpiPin(14, 12, 13, 5, 0);
  ELECHOUSE_cc1101.addSpiPin(14, 12, 13, 27, 1);
  appendFile(SD, "/logs.txt","Viewlog:\n", "<br>\n");
}

void signalanalyse(){
  #define signalstorage 10

  int signalanz=0;
  int timingdelay[signalstorage];
  float pulse[signalstorage];
  long signaltimings[signalstorage*2];
  int signaltimingscount[signalstorage];
  long signaltimingssum[signalstorage];
  long signalsum=0;

  for (int i = 0; i<signalstorage; i++){
    signaltimings[i*2] = 100000;
    signaltimings[i*2+1] = 0;
    signaltimingscount[i] = 0;
    signaltimingssum[i] = 0;
  }
  for (int i = 1; i<samplecount; i++){
    signalsum+=sample[i];
  }

  for (int p = 0; p<signalstorage; p++){

  for (int i = 1; i<samplecount; i++){
    if (p==0){
      if (sample[i]<signaltimings[p*2]){
        signaltimings[p*2]=sample[i];
      }
    }else{
      if (sample[i]<signaltimings[p*2] && sample[i]>signaltimings[p*2-1]){
        signaltimings[p*2]=sample[i];
      }
    }
  }

  for (int i = 1; i<samplecount; i++){
    if (sample[i]<signaltimings[p*2]+error_toleranz && sample[i]>signaltimings[p*2+1]){
      signaltimings[p*2+1]=sample[i];
    }
  }

  for (int i = 1; i<samplecount; i++){
    if (sample[i]>=signaltimings[p*2] && sample[i]<=signaltimings[p*2+1]){
      signaltimingscount[p]++;
      signaltimingssum[p]+=sample[i];
    }
  }
  }
  
  int firstsample = signaltimings[0];
  
  signalanz=signalstorage;
  for (int i = 0; i<signalstorage; i++){
    if (signaltimingscount[i] == 0){
      signalanz=i;
      i=signalstorage;
    }
  }

  for (int s=1; s<signalanz; s++){
  for (int i=0; i<signalanz-s; i++){
    if (signaltimingscount[i] < signaltimingscount[i+1]){
      int temp1 = signaltimings[i*2];
      int temp2 = signaltimings[i*2+1];
      int temp3 = signaltimingssum[i];
      int temp4 = signaltimingscount[i];
      signaltimings[i*2] = signaltimings[(i+1)*2];
      signaltimings[i*2+1] = signaltimings[(i+1)*2+1];
      signaltimingssum[i] = signaltimingssum[i+1];
      signaltimingscount[i] = signaltimingscount[i+1];
      signaltimings[(i+1)*2] = temp1;
      signaltimings[(i+1)*2+1] = temp2;
      signaltimingssum[i+1] = temp3;
      signaltimingscount[i+1] = temp4;
    }
  }
  }

  for (int i=0; i<signalanz; i++){
    timingdelay[i] = signaltimingssum[i]/signaltimingscount[i];
  }

  if (firstsample == sample[1] and firstsample < timingdelay[0]){
    sample[1] = timingdelay[0];
  }


  bool lastbin=0;
  for (int i=1; i<samplecount; i++){
    float r = (float)sample[i]/timingdelay[0];
    int calculate = r;
    r = r-calculate;
    r*=10;
    if (r>=5){calculate+=1;}
    if (calculate>0){
      if (lastbin==0){
        lastbin=1;
      }else{
      lastbin=0;
    }
      if (lastbin==0 && calculate>8){
        Serial.print(" [Pause: ");
        Serial.print(sample[i]);
        Serial.println(" samples]");
        appendFile(SD, "/logs.txt",NULL, " [Pause: ");
        appendFileLong(SD, "/logs.txt", sample[i]);
        appendFile(SD, "/logs.txt"," samples]", "\n");
      }else{
        for (int b=0; b<calculate; b++){
          Serial.print(lastbin);
          appendFileLong(SD, "/logs.txt", lastbin);
        }
      }
    }
  }
  Serial.println();
  Serial.print("Samples/Symbol: ");
  Serial.println(timingdelay[0]);
  Serial.println();
  appendFile(SD, "/logs.txt","<br>\n", "<br>\n");
  appendFile(SD, "/logs.txt",NULL, "Samples/Symbol: ");
  appendFileLong(SD, "/logs.txt", timingdelay[0]);
  appendFile(SD, "/logs.txt",NULL, "<br>\n");

  int smoothcount=0;
  for (int i=1; i<samplecount; i++){
    float r = (float)sample[i]/timingdelay[0];
    int calculate = r;
    r = r-calculate;
    r*=10;
    if (r>=5){calculate+=1;}
    if (calculate>0){
      samplesmooth[smoothcount] = calculate*timingdelay[0];
      smoothcount++;
    }
  }
  Serial.println("Rawdata corrected:");
  Serial.print("Count=");
  Serial.println(smoothcount+1);
  appendFile(SD, "/logs.txt",NULL, "Count=");
  appendFileLong(SD, "/logs.txt", smoothcount+1);
  appendFile(SD, "/logs.txt","\n", "<br>\n");
  appendFile(SD, "/logs.txt",NULL, "Rawdata corrected:\n");
  for (int i=0; i<smoothcount; i++){
    Serial.print(samplesmooth[i]);
    Serial.print(",");
    transmit_push[i] = samplesmooth[i];
    appendFileLong(SD, "/logs.txt", samplesmooth[i]);
    appendFile(SD, "/logs.txt", NULL, ",");  
  }
  Serial.println();
  Serial.println();
  appendFile(SD, "/logs.txt", NULL, "<br>\n");
  appendFile(SD, "/logs.txt", "-------------------------------------------------------\n", "<br>");
  return;
}

void loop() {
  
  poweron_blink();
  
  pushbutton1 = digitalRead(push1);
  pushbutton2 = digitalRead(push2);

  if(raw_rx == "1") {
    if(checkReceived()){
      printReceived();
      signalanalyse();
      enableReceive();
      delay(200);
      //sdspi.end();
      //sdspi.begin(18, 19, 23, 22);
      //SD.begin(22, sdspi);
      delay(500);
    }
  }

  if(jammer_tx == "1") {
    raw_rx = "0";
    
    if (tmp_module == "1") {
      for (int i = 0; i<12; i+=2){
        digitalWrite(2,HIGH);
        delayMicroseconds(jammer[i]);
        digitalWrite(2,LOW);
        delayMicroseconds(jammer[i+1]);
      }
    }
    else if (tmp_module == "2") {
      for (int i = 0; i<12; i+=2){
        digitalWrite(25,HIGH);
        delayMicroseconds(jammer[i]);
        digitalWrite(25,LOW);
        delayMicroseconds(jammer[i+1]);
      }
    }
  }

  if (pushbutton1 == LOW) {
    if (btn1tesla == "1") {
      sendSignalsBT1();
    } else {
    raw_rx = "0";
    tmp_btn1_deviation = btn1_deviation.toFloat();
    tmp_btn1_mod = btn1_mod.toInt();
    tmp_btn1_frequency = btn1_frequency.toFloat();
    tmp_btn1_transmission = btn1_transmission.toInt();
    pinMode(25,OUTPUT);
    ELECHOUSE_cc1101.setModul(1);
    ELECHOUSE_cc1101.Init();
    ELECHOUSE_cc1101.setModulation(tmp_btn1_mod);
    ELECHOUSE_cc1101.setMHZ(tmp_btn1_frequency);
    ELECHOUSE_cc1101.setDeviation(tmp_btn1_deviation);
    //delay(400);
    ELECHOUSE_cc1101.SetTx();

    for (int r = 0; r<tmp_btn1_transmission; r++) {
        for (int i = 0; i<counter; i+=2){
          digitalWrite(25,HIGH);
          delayMicroseconds(data_button1[i]);
          digitalWrite(25,LOW);
          delayMicroseconds(data_button1[i+1]);
          Serial.print(data_button1[i]);
          Serial.print(",");
        }
        delay(2000); //Set this for the delay between retransmissions
      }
     Serial.println();
     ELECHOUSE_cc1101.setSidle();
  }
  }

  if (pushbutton2 == LOW) {
    if (btn2tesla == "1") {
      sendSignalsBT2();
    } else {
    raw_rx = "0";
    tmp_btn2_deviation = btn2_deviation.toFloat();
    tmp_btn2_mod = btn2_mod.toInt();
    tmp_btn2_frequency = btn2_frequency.toFloat();
    tmp_btn2_transmission = btn2_transmission.toInt();
    pinMode(25,OUTPUT);
    ELECHOUSE_cc1101.setModul(1);
    ELECHOUSE_cc1101.Init();
    ELECHOUSE_cc1101.setModulation(tmp_btn2_mod);
    ELECHOUSE_cc1101.setMHZ(tmp_btn2_frequency);
    ELECHOUSE_cc1101.setDeviation(tmp_btn2_deviation);
    ELECHOUSE_cc1101.SetTx();

    for (int r = 0; r<tmp_btn2_transmission; r++) {
        for (int i = 0; i<counter; i+=2){
          digitalWrite(25,HIGH);
          delayMicroseconds(data_button2[i]);
          digitalWrite(25,LOW);
          delayMicroseconds(data_button2[i+1]);
          Serial.print(data_button2[i]);
          Serial.print(",");
        }
        delay(2000); //Set this for the delay between retransmissions
      }
     Serial.println();
     ELECHOUSE_cc1101.setSidle();
  }
  }
}
